use crate::chain;
use crate::regression;
use crate::file_io;
use crate::params::*;
use crate::screen;
use crate::sketch_db::{SketchDbReader, is_consolidated_db, has_separate_sketches};
use crate::types::*;
use fxhash::FxHashMap;
use log::*;
use rayon::prelude::*;
use std::path::Path;
use std::sync::Mutex;
use std::sync::RwLock;
use std::time::Instant;

pub fn search(command_params: CommandParams) {
    let now = Instant::now();
    info!("Searching...");
    let mut ref_marker_file = "";
    for file in command_params.ref_files.iter() {
        if !file.contains(".sketch") && !file.contains("marker") && !file.ends_with("db"){
            warn!(
                "{} does not have .sketch as an extension; skipping file",
                file
            );
        } else if file.contains("markers.bin") {
            ref_marker_file = file;
        }
    }

    if ref_marker_file.is_empty() {
        //error!("No sketch files found in the folder. Sketch files must be generated by `skani sketch` and have the .sketch extension.");
        error!("markers.bin not found in the folder. Ensure that the folder was generated by `skani sketch`.");
        std::process::exit(1)
    }

    let ref_sketches;
    let sketch_params;
    (sketch_params, ref_sketches) = file_io::marker_sketches_from_marker_file(ref_marker_file);
    let screen_val;
    if command_params.screen_val == 0. {
        if sketch_params.use_aa {
            screen_val = SEARCH_AAI_CUTOFF_DEFAULT;
        } else {
            screen_val = SEARCH_ANI_CUTOFF_DEFAULT;
        }
    } else {
        screen_val = command_params.screen_val;
    }



    let learned_ani = regression::use_learned_ani(sketch_params.c, command_params.individual_contig_q, false, command_params.median);
    let model_opt = regression::get_model(sketch_params.c, learned_ani);
    if model_opt.is_some() {
        info!("{}", LEARNED_INFO_HELP);
    }

    info!("Loading markers time: {}", now.elapsed().as_secs_f32());
    let kmer_to_sketch;
    if command_params.screen {
        let now = Instant::now();
        info!("Full index option detected; generating marker hash table");
        kmer_to_sketch = screen::kmer_to_sketch_from_refs(&ref_sketches);
        info!("Full indexing time: {}", now.elapsed().as_secs_f32());
    } else {
        kmer_to_sketch = KmerToSketch::default();
    }
    let ref_sketches_used: RwLock<FxHashMap<_, _>> = RwLock::new(FxHashMap::default());

    let now = Instant::now();
    //assert!(ref_sketches.len() == ref_marker_files.len());
    let anis: Mutex<Vec<AniEstResult>> = Mutex::new(vec![]);
    let counter: Mutex<usize> = Mutex::new(0);
    let first_write: Mutex<bool> = Mutex::new(true);
    let folder = Path::new(&ref_marker_file).parent().unwrap();
    let folder_str = folder.to_str().unwrap();
    
    // Detect database format and initialize reader if consolidated
    let db_reader_opt = if is_consolidated_db(folder_str) {
        info!("Detected consolidated sketch database format");
        match SketchDbReader::new(folder_str) {
            Ok(reader) => Some(reader),
            Err(e) => {
                error!("Failed to load consolidated database: {}", e);
                std::process::exit(1);
            }
        }
    } else if has_separate_sketches(folder_str) {
        info!("Detected separate sketch files format");
        None
    } else {
        error!("No valid sketch database format found in directory");
        std::process::exit(1);
    };
    
    for query_file in command_params.query_files.iter() {
        let query_params;
        let query_sketches;
        if command_params.queries_are_sketch {
            (query_params, query_sketches) =
                file_io::sketches_from_sketch(&vec![query_file.clone()]);
            if query_params != sketch_params && !query_file.contains("markers.bin") {
                warn!("Query sketch parameters for {} not equal to reference sketch parameters; no ANI calculated", query_file);
            }
        } else if command_params.individual_contig_q {
            query_sketches = file_io::fastx_to_multiple_sketch_rewrite(
                &vec![query_file.clone()],
                &sketch_params,
                true,
            );
        } else {
            query_sketches =
                file_io::fastx_to_sketches(&vec![query_file.clone()], &sketch_params, true);
        }

        if !query_sketches.is_empty() {
            let is = 0..query_sketches.len();
            is.into_par_iter().for_each(|i| {
                let query_sketch = &query_sketches[i];
                let ref_indices_to_try;
                if !command_params.screen {
                    let refs_to_try_mutex: Mutex<Vec<usize>> = Mutex::new(vec![]);
                    let js = 0..ref_sketches.len();
                    js.into_par_iter().for_each(|j| {
                        let ref_sketch = &ref_sketches[j];
                        if screen::check_markers_quickly(query_sketch, ref_sketch, screen_val, false) {
                            let mut lock = refs_to_try_mutex.lock().unwrap();
                            lock.push(j);
                        }
                    });
                    ref_indices_to_try = refs_to_try_mutex.into_inner().unwrap();
                } else {
                    ref_indices_to_try = screen::screen_refs_indices(
                        screen_val,
                        &kmer_to_sketch,
                        query_sketch,
                        &sketch_params,
                        &ref_sketches,
                    );
                }
                ref_indices_to_try.into_par_iter().for_each(|j| {
                    let original_file = &ref_sketches[j].file_name;
                    let ref_sketch;
                    if !command_params.keep_refs {
                        let ref_sketch_new = if let Some(ref db_reader) = &db_reader_opt {
                            // Load from consolidated database
                            match db_reader.get_sketch(j) {
                                Ok((_params, sketch)) => vec![sketch],
                                Err(e) => {
                                    error!("Failed to load sketch {}: {}", original_file, e);
                                    return;
                                }
                            }
                        } else {
                            // Load from separate sketch file
                            let sketch_file = folder.join(
                                Path::new(&format!("{}.sketch", original_file))
                                    .file_name()
                                    .unwrap(),
                            );
                            let (_sketch_params_ref, sketches) = file_io::sketches_from_sketch(
                                &vec![sketch_file.to_str().unwrap().to_string()],
                            );
                            sketches
                        };
                        ref_sketch = ref_sketch_new;
                        let map_params = chain::map_params_from_sketch(
                            &ref_sketch[0],
                            sketch_params.use_aa,
                            &command_params,
                            &model_opt
                        );
                        let ani_res;
                        ani_res = chain::chain_seeds(&ref_sketch[0], query_sketch, map_params);
                        if ani_res.ani > 0.5 {
                            let mut locked = anis.lock().unwrap();
                            locked.push(ani_res);
                        }
                    } else {
                        let mut contains = false;
                        {
                            let read_table = ref_sketches_used.read().unwrap();
                            if read_table.contains_key(original_file) {
                                contains = true;
                            }
                        }
                        if contains {
                            let read_table = ref_sketches_used.read().unwrap();
                            let ref_sketch: &Vec<_> = &read_table[original_file];
                            let map_params = chain::map_params_from_sketch(
                                &ref_sketch[0],
                                sketch_params.use_aa,
                                &command_params,
                                &model_opt
                            );
                            let ani_res;
                                ani_res = chain::chain_seeds(&ref_sketch[0], query_sketch, map_params);
                            if ani_res.ani > 0.5 {
                                let mut locked = anis.lock().unwrap();
                                locked.push(ani_res);
                            }
                        } else {
                            let ref_sketch = if let Some(ref db_reader) = &db_reader_opt {
                                // Load from consolidated database
                                match db_reader.get_sketch(j) {
                                    Ok((_params, sketch)) => vec![sketch],
                                    Err(e) => {
                                        error!("Failed to load sketch {}: {}", original_file, e);
                                        return;
                                    }
                                }
                            } else {
                                // Load from separate sketch file
                                let sketch_file = folder.join(
                                    Path::new(&format!("{}.sketch", original_file))
                                        .file_name()
                                        .unwrap(),
                                );
                                let (_sketch_params_ref, sketches) = file_io::sketches_from_sketch(
                                    &vec![sketch_file.to_str().unwrap().to_string()],
                                );
                                sketches
                            };

                            let map_params = chain::map_params_from_sketch(
                                &ref_sketch[0],
                                sketch_params.use_aa,
                                &command_params,
                                &model_opt
                            );
                            let ani_res;
                            ani_res = chain::chain_seeds(&ref_sketch[0], query_sketch, map_params);
                            {
                                let mut write_table = ref_sketches_used.write().unwrap();
                                write_table.insert(original_file.clone(), ref_sketch);
                            }

                            if ani_res.ani > 0.5 {
                                {
                                    let mut locked = anis.lock().unwrap();
                                    locked.push(ani_res);
                                }
                            }
                        }
                    }
                });

                let c;
                {
                    let mut locked = counter.lock().unwrap();
                    *locked += 1;
                    c = *locked
                }
                if c % 100 == 0 && c != 0 {
                    info!("{} query sequences processed.", c);
                    if c % INTERMEDIATE_WRITE_COUNT == 0 && c != 0{
                        info!("Writing results for {} query sequences.", INTERMEDIATE_WRITE_COUNT);
                        let moved_anis: Vec<AniEstResult>;
                        {
                        let mut locked = anis.lock().unwrap();
                        moved_anis = std::mem::take(&mut locked);
                        }
                        let mut fw = first_write.lock().unwrap();
                        file_io::write_query_ref_list(
                            &moved_anis,
                            &command_params.out_file_name,
                            command_params.max_results,
                            sketch_params.use_aa,
                            command_params.est_ci,
                            command_params.detailed_out,
                            !*fw,
                            command_params.short_header,
                        );
                        if *fw == true{
                            *fw = false;
                        }
                    }
                }
            });
        }
    }
    if command_params.keep_refs{
        info!("{} references kept in memory for --keep-refs", ref_sketches_used.read().unwrap().len());
    }
    
    let anis = anis.into_inner().unwrap();
    
    file_io::write_query_ref_list(
        &anis,
        &command_params.out_file_name,
        command_params.max_results,
        sketch_params.use_aa,
        command_params.est_ci,
        command_params.detailed_out,
        !*first_write.lock().unwrap(),
        command_params.short_header,
    );
    info!("Searching time: {}", now.elapsed().as_secs_f32());
}
